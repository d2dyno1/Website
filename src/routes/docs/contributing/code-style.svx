# Code quality standards
  All code contributed to the repository must follow our [Model-View-ViewModel](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel) design path.
  The code must be well-written and expose a clear purpose. Workarounds are not welcome unless the scope of the PR touches external components
  (OS functions/API calls) that require unconventional practices of coding.
  Your code must be easily maintainable without requiring to rewrite core parts, making sure no code is being duplicated, utilizing abstractions and inheritance
  is a great way to sustain high code metrics. Your code must also be tested for potential regressions and unwanted memory leaks.
  
  We also prioritize accessibility, to check whether your pull request meets our accessibility standards, you're encouraged to use [Accessibility Insights for Windows](https://accessibilityinsights.io/docs/en/windows/overview/)
  to ensure everyone can take full advantage of Files.
  
# Code Style

To make the codebase consistent and easy to understand, we require you to follow our predefined code style rules:

1. Naming notation for objects and functions
- Use PascalCase for classes
- Use PascalCase prefixed with 'I' for interfaces
- Use PascalCase for structs
- Use PascalCase for functions/methods
- Use "Base" prefix for base classes
- Use "Service" suffix for service classes and interfaces
- Use "Model" suffix for model classes
- Use "ViewModel" suffix for view model classes
- Use "Dialog" suffix for dialog controls
- Use "Control" suffix for user controls
- Use "Page" suffix for pages

2. Naming notation for variables
- Use PascalCase for private/protected/public static fields/properties
- Use PascalCase for properties
- Use PascalCase prefixed with '_' for private fields backing properties
- Use camelCase for protected and public fields
- Use camelCase for protected fields backing properties
- Use camelCase prefixed with '_' for private fields
- Use camelCase for method parameters
- Use Hungarian Notation only for OS functions/API calls
- Use UPPER_CASE for constant variables
- Use predefined primitive types like `int`, `long`, `string` instead of `Int32`, `Int64`, `String`

3. Code readability and clarity
- Use curly brackets for single line `if`, `for` and `foreach` statements.'
- Do not use `#region` directives
- Align `while();` on the same line of curly bracket of `do..while`
- Use the prefixes `Is`, `Has`, `Have`, `Any`, `Can` or similar keywords for boolean names and method names if applicable.
- Do not use `Enum` or `Flag(s)` suffixes/prefixes for Enum names.
- Align curly brackets on new lines
- Fields, properties, methods and constructors must be separated by one line
  except for property backing fields that are not separated by any amount of lines
- Do not manually invoke event handling functions or commands
- Do not use `public` modifiers in interface's properties and functions
- Do not prefix interface name before implementing function/property unless necessary
- Define constant types in `Constants` class following its structure
- Mark classes as `abstract` or `sealed` if applicable.
- Use single line return `=>` for simple functions
- Complex classes and interfaces must be documented
- You are obliged to use [XAML Styler](https://marketplace.visualstudio.com/items?itemName=TeamXavalon.XAMLStyler2022) for styling XAML

3. Class structure
The following presents how a class structure should be ordered:

- private/protected/public (internal) static fields
- readonly private/protected/public (internal) static fields
- private/protected/public (internal) static properties

- readonly private/protected/public (internal) fields
- private/protected/public (internal) fields

- private/protected/public (internal) service property

- private/protected/public (internal) property backing fields
- private/protected/public (internal) properties
- private/protected/public (internal) UI properties
- private/protected/public (internal) ICommand properties;

- private/protected/public (internal) constructor

- Command implementation functions (private only)

- public (virtual/override) functions/methods (with parameters amount descending)
- private functions/methods
- protected (virtual/override) functions/methods (with parameters amount descending)

- public/protected abstract functions/methods

- IDisposable.Dispose() function

4. Interface structure
The following presents how an interface structure should be ordered:

- properties
- functions (with parameters amount descending)
- functions (without parameters)

5. Helper classes and extensions
- Helper classes must be static and contain functions designated to their goal
- Extension classes must be static and only contain extension functions related to one type or derivatives



